#version 430 core

uniform float	sigma;
uniform float	spreading;
uniform ivec2	pass;
uniform float	glareFactor;

layout (binding = 0) uniform sampler2D textureInput;
layout (binding = 1, rgba16f) uniform image2D finalOutput;

// we use 16 * 16 threads groups
layout (local_size_x = 16, local_size_y = 16) in;

void	main()
{
	ivec2		position = ivec2(gl_GlobalInvocationID.xy);
	ivec2		inputSize = textureSize(textureInput, 0);

	if (position.x < inputSize.x &&
		position.y < inputSize.y)
	{
		float	glareThreshold = glareFactor * float(pass.x);
		vec3	baseColor = texture(textureInput, vec2(position) / inputSize).rgb;
		float	g0, g1, g2, coefSum;

		g0 = 1.0 / (sqrt(2.0 * 3.1415926535) * sigma);
		g1 = exp(-0.5f / (sigma * sigma));
		g2 = g1 * g1;
		coefSum = g0;
		g0 *= g1;
		g1 *= g2;

		vec3	finalColor = (baseColor - vec3(glareThreshold)) * g0;

		for (uint i = 1; i < uint(3.0f * sigma); i++)
		{
			vec2	pxlPosition1 = vec2(position) + vec2(pass) * vec2(i) * vec2(spreading);
			vec2	pxlPosition2 = vec2(position) - vec2(pass) * vec2(i) * vec2(spreading);
			finalColor += max(texture(textureInput, pxlPosition1 / vec2(inputSize)).rgb - vec3(glareThreshold), vec3(0)) * g0;
			finalColor += max(texture(textureInput, pxlPosition2 / vec2(inputSize)).rgb - vec3(glareThreshold), vec3(0)) * g0;

			coefSum += 2.0f * g0;
			g0 *= g1;
			g1 *= g2;
		}
		vec3	pxlColor = imageLoad(finalOutput, position).rgb * vec3(pass.y);
		imageStore(finalOutput, position, vec4(pxlColor + max(finalColor / coefSum, vec3(0)), 1.0f));
	}
}